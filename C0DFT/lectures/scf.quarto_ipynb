{
  "cells": [
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "<!-- ---\n",
        "title: \"SCF Calculation\"\n",
        "format: html\n",
        "--- -->\n",
        "\n",
        "## Self-Consistent Field (SCF)\n",
        "\n",
        "SCF calculations solve many one particle Schrodinger like KS equation (eq. num) for a given system. This problem is called *self consistent* because Hartee and exchange-correlation potential in KS equation require the electron density which require wave function $\\psi$ to obtain the solution to the equation. Or simple, a wavefunction $\\psi_i$ is dependent on all the other solutions $\\psi_j$ describing the electronic states. Therefore, SCF calculation is an itterative process and solve the equations numerically.\n",
        "\n",
        "Practically, nuclear potential is calculated by giving the atomic site coordinates and $V_H$ and $V_XC$ are calculated using the initial guess of electron density. This way, the total potential is calculated which is used by KS equations to calculate wavefunction and then obtain the electron density. The process is repeated until the value of electron density converges to obtain the ground state energy. Flow chart below shows the cyclic process of SCF calculations.\n",
        "\n",
        "\n",
        "![SCF Flow Diagram](figs_DFT/KS-method.png){width=60%}\n",
        "\n",
        "\n",
        "## Calculations\n",
        "\n",
        "SCF calculations give the total energy of the system to obtain the ground state properties of material. But prior to scf calculations, relaxation calculation is necessary to remove the strains on the system and optimize the atomic positions as well as unit cell. QE uses BFGS algorithm (**Do i need to explain BFGS theorem?**) to optimize the atomic positions through *relax* and cell parameters through *vc-relax* calculation. It is itterative process similar to scf calculations where BFGS algorithm obtain the values of atomic positions and then energy is calculated through SCF calculation and forces are calculated using Hellmann‚ÄêFeynman theorem. The cycle stops when the energy and forces values achieve convergence criteris provided in the input file. Sample files of relax, vc-relax and scf calculation can be found at:\n",
        "\n",
        "- relax.in\n",
        "- vc-relax.in\n",
        "\n",
        "- [scf.in](inputfiles/scfin.qmd)\n",
        "\n",
        "## Run Calculations\n",
        "QE uses pw.x code to run the above calculations. The difference is only in the input files. First run relx/vcrelax and obtain the corresponding optimized atomicc positions and cell parameters. Then perform convergence test and finaly perform the SCF calculation with optimized parameters.\n",
        "\n",
        "```bash\n",
        "mpirun -np 4 pw.x < relax.in > relax.out\n",
        "mpirun -np 4 pw.x < vcrelax.in > vcrelax.out\n",
        "mpirun -np 4 pw.x < scf.in > scf.out\n",
        "```\n",
        "\n",
        "## Convergence in SCF calculations\n",
        "Convergence test should be perform on *energ cutoff* and *k-mesh* after structure relaxation as shown below in graph to obtain the correct parameters. For this purpose, perform multiple scf calculations for different values. \n",
        "\n",
        "The energy cutoff determines how many plane waves are to be used for calculations which is directly related to the accuracy of results. However, it is to keep in mind that higher energy cutoff increases the computational cost. Mostly pseudopotential files provide the estimated energy cutoff but it is still recommended to perform convergence test. Ultrasoft pseudopotentials suggest low energy cutoff while it is larger for norm conserving pseudopotentials. \n",
        "\n",
        "\n",
        "*k-mesh* convergence can be performed by changing the k points in the input file of QE. There are six values: first 3 values are number of k-points and the last 3 values represent lattice shifting in each direction which can take value either 0 or 1.  \n"
      ],
      "id": "527977fa"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "import plotly.graph_objects as go\n",
        "import numpy as np\n",
        "\n",
        "# SCF iteration data\n",
        "iterations = np.arange(1, 21)\n",
        "energies = -50 + np.exp(-0.3 * iterations)\n",
        "\n",
        "# Create frames (one per iteration step)\n",
        "frames = [\n",
        "    go.Frame(\n",
        "        data=[go.Scatter(x=iterations[:k], y=energies[:k], mode='lines+markers')],\n",
        "        name=str(k)\n",
        "    )\n",
        "    for k in range(1, 21)\n",
        "]\n",
        "\n",
        "# Initial plot with only first point\n",
        "fig = go.Figure(\n",
        "    data=[go.Scatter(x=iterations[:1], y=energies[:1], mode='lines+markers')],\n",
        "    layout=go.Layout(\n",
        "        title=\"SCF Energy Convergence\",\n",
        "        xaxis_title=\"Iteration\",\n",
        "        yaxis_title=\"Total Energy (a.u.)\",\n",
        "        sliders=[{\n",
        "            \"steps\": [{\n",
        "                \"method\": \"animate\",\n",
        "                \"args\": [[str(k)]],\n",
        "                \"label\": str(k)\n",
        "            } for k in range(1, 21)]\n",
        "        }]\n",
        "    ),\n",
        "    frames=frames\n",
        ")\n",
        "\n",
        "fig.show()"
      ],
      "id": "463ff245",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "## Before You Run It\n",
        "\n",
        "\n",
        "\n",
        ":::: {.ddm style=\"font-size:0.8em; line-height:0\"}\n",
        ":::{.ddm-head onclick=\"toggleBox(this)\" style=\"border-bottom: px solid red;font-family:EB Garamond It\"}\n",
        "\n",
        "How to restart scf calculation?\n",
        ":::\n",
        "\n",
        ":::{.ddm-box style=\"font-family:EB Garamond It;border-color:transparent\"}\n",
        "\n",
        "can use restart option\n",
        "\n",
        ":::\n",
        "::::\n",
        "\n",
        "\n",
        ":::: {.ddm style=\"font-size:0.8em; line-height:0\"}\n",
        ":::{.ddm-head onclick=\"toggleBox(this)\" style=\"border-bottom: px solid red;font-family:EB Garamond It\"}\n",
        "\n",
        "When to use relax and vc-relax?\n",
        ":::\n",
        "\n",
        ":::{.ddm-box style=\"font-family:EB Garamond It;border-color:transparent\"}\n",
        "\n",
        "answer\n",
        "\n",
        ":::\n",
        "::::\n",
        "\n",
        "\n",
        ":::: {.ddm style=\"font-size:0.8em; line-height:0\"}\n",
        ":::{.ddm-head onclick=\"toggleBox(this)\" style=\"border-bottom: px solid red;font-family:EB Garamond It\"}\n",
        "\n",
        "Use *space_group* to employ symmetry and reduce computational cost\n",
        ":::\n",
        "\n",
        ":::{.ddm-box style=\"font-family:EB Garamond It;border-color:transparent\"}\n",
        "\n",
        "answer\n",
        "\n",
        ":::\n",
        "::::\n",
        "\n",
        ":::: {.ddm style=\"font-size:0.8em; line-height:0\"}\n",
        ":::{.ddm-head onclick=\"toggleBox(this)\" style=\"border-bottom: px solid red;font-family:EB Garamond It\"}\n",
        "\n",
        "When to use k-points shifting?\n",
        ":::\n",
        "\n",
        ":::{.ddm-box style=\"font-family:EB Garamond It;border-color:transparent\"}\n",
        "\n",
        "Book- page 40 onwards\n",
        "\n",
        ":::\n",
        "::::\n",
        "\n",
        ":::: {.ddm style=\"font-size:0.8em; line-height:0\"}\n",
        ":::{.ddm-head onclick=\"toggleBox(this)\" style=\"border-bottom: px solid red;font-family:EB Garamond It\"}\n",
        "\n",
        "Any rule for selecting k-points?\n",
        ":::\n",
        "\n",
        ":::{.ddm-box style=\"font-family:EB Garamond It;border-color:transparent\"}\n",
        "\n",
        "Book- page 40 onwards\n",
        "\n",
        ":::\n",
        "::::\n",
        "\n",
        "\n",
        ":::: {.ddm style=\"font-size:0.8em; line-height:0\"}\n",
        ":::{.ddm-head onclick=\"toggleBox(this)\" style=\"border-bottom: px solid red;font-family:EB Garamond It\"}\n",
        "\n",
        "How to check convergence?\n",
        ":::\n",
        "\n",
        ":::{.ddm-box style=\"font-family:EB Garamond It;border-color:transparent\"}\n",
        "\n",
        "nswer\n",
        "\n",
        ":::\n",
        "::::\n",
        "\n",
        ":::: {.ddm style=\"font-size:0.8em; line-height:0\"}\n",
        ":::{.ddm-head onclick=\"toggleBox(this)\" style=\"border-bottom: px solid red;font-family:EB Garamond It\"}\n",
        "\n",
        "How to set convergence criteria for relax and vcrelax calculation?\n",
        ":::\n",
        "\n",
        ":::{.ddm-box style=\"font-family:EB Garamond It;border-color:transparent\"}\n",
        "\n",
        "- etot_conv_thr\n",
        "-  forc_conv_thr\n",
        "\n",
        "\n",
        "-  press_conv_thr\n",
        "\n",
        ":::\n",
        "::::\n",
        "\n",
        "\n",
        "\n",
        "## Output plotting and interpretation\n",
        "\n",
        " - explanation of relax.out\n",
        " - explanation of vcrelax\n",
        " - explanation of scf\n",
        "\n",
        "## Exercise Questions\n",
        "- **Write the**"
      ],
      "id": "1128c9e1"
    }
  ],
  "metadata": {
    "kernelspec": {
      "name": "dft_env",
      "language": "python",
      "display_name": "Python (dft_env)",
      "path": "C:\\Users\\HP\\AppData\\Roaming\\jupyter\\kernels\\dft_env"
    }
  },
  "nbformat": 4,
  "nbformat_minor": 5
}